<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‰‹åŠ¿æ§åˆ¶ç²’å­æ•ˆæœ</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    #canvas-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover; /* ç¡®ä¿è§†é¢‘å¡«å……æ•´ä¸ªå®¹å™¨ */
      opacity: 0.3;
      z-index: 1;
    }
    #output {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 10;
      font-size: 18px;
    }
    #error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      z-index: 20;
      font-size: 20px;
      text-align: center;
      background-color: rgba(255, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
    }
    #controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      color: white;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 90vw;
    }
    .controls-text {
      width: 100%;
      text-align: center;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      min-width: 120px;
    }
    #auto-detect-btn {
      background-color: #f44336;
    }
    #debug {
      position: absolute;
      top: 50px;
      left: 10px;
      color: white;
      z-index: 10;
      font-size: 12px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      z-index: 30;
      font-size: 24px;
      text-align: center;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <video id="video" autoplay playsinline style="display: none;"></video>
    <div id="output"></div>
    <div id="debug"></div>
    <div id="loading">æ­£åœ¨åŠ è½½æ¨¡å‹...</div>
    <div id="controls">
      <p class="controls-text">æ— æ‘„åƒå¤´æ—¶ä½¿ç”¨æ‰‹åŠ¨æ§åˆ¶ï¼š</p>
      <button onclick="setFingerCount(0)">æ¡æ‹³</button>
      <button onclick="setFingerCount(1)">1æ ¹æ‰‹æŒ‡</button>
      <button onclick="setFingerCount(2)">2æ ¹æ‰‹æŒ‡</button>
      <button onclick="setFingerCount(3)">3æ ¹æ‰‹æŒ‡</button>
      <button onclick="setFingerCount(4)">4æ ¹æ‰‹æŒ‡</button>
      <button onclick="setFingerCount(5)">5æ ¹æ‰‹æŒ‡</button>
      <button id="auto-detect-btn" onclick="enableAutoDetection()">å…³é—­è‡ªåŠ¨æ£€æµ‹</button>
    </div>
  </div>

  <!-- å¼•å…¥åº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.10/p5.min.js"></script>
  <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>

  <script>
    // å…¨å±€å˜é‡
    let handpose, video, predictions = [];
    let particleSystem;
    let manualFingerCount = 5; // é»˜è®¤5æ ¹æ‰‹æŒ‡ï¼ˆæ•£å¼€ï¼‰
    let useManualControl = false; // é»˜è®¤ä½¿ç”¨è‡ªåŠ¨æ§åˆ¶
    let debugEnabled = false; // æ˜¯å¦æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    let fingerCount = 5; // å½“å‰æ‰‹æŒ‡æ•°é‡
    const minFingerLength = 10
    let modelLoaded = false; // æ¨¡å‹åŠ è½½çŠ¶æ€
    let resizeTimeout = null; // èŠ‚æµå®šæ—¶å™¨
    const RESIZE_THROTTLE_DELAY = 500;

    function preload() {
      // åŠ è½½ handpose æ¨¡å‹
      handpose = ml5.handPose(() => {
        console.log('Handpose æ¨¡å‹å·²åŠ è½½');
        modelLoaded = true;
        document.getElementById('loading').classList.add('hidden');
        showError('æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ªï¼Œè¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰');
      });
    }

    function setup() {
      const container = document.getElementById('canvas-container');
      createCanvas(window.innerWidth, window.innerHeight);
      
      // åˆ›å»ºæ‘„åƒå¤´è§†é¢‘
      video = createCapture(VIDEO);
      video.size(window.innerWidth, window.innerHeight);
      video.hide();
      
      // å¼€å§‹æ‰‹åŠ¿æ£€æµ‹ï¼ˆé»˜è®¤ä¸å¯åŠ¨ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»å¼€å¯ï¼‰
      handpose.detectStart(video, gotHands);
      
      // åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
      particleSystem = new ParticleSystem();
      
      // å“åº”çª—å£å¤§å°å˜åŒ–
      window.addEventListener('resize', () => {
        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }
        
        // ç«‹å³è°ƒæ•´ç”»å¸ƒå’Œè§†é¢‘å¤§å°
        resizeCanvas(window.innerWidth, window.innerHeight);
        video.size(window.innerWidth, window.innerHeight);
        
        // è®¾ç½®èŠ‚æµå®šæ—¶å™¨ï¼Œå»¶è¿Ÿé‡æ–°è®¡ç®—ç²’å­å½¢çŠ¶
        resizeTimeout = setTimeout(() => {
          // æ£€æŸ¥ç²’å­ç³»ç»Ÿæ˜¯å¦å­˜åœ¨ä¸”å…·æœ‰precomputeShapesæ–¹æ³•
          if (particleSystem && typeof particleSystem.precomputeShapes === 'function') {
            particleSystem.precomputeShapes();
            console.log('çª—å£å¤§å°æ”¹å˜ï¼Œé‡æ–°è®¡ç®—ç²’å­å½¢çŠ¶');
          }
        }, RESIZE_THROTTLE_DELAY);
      });
      
      // å»¶è¿Ÿ3ç§’åå¯ç”¨è°ƒè¯•æ¨¡å¼
      setTimeout(() => {
        debugEnabled = true;
      }, 3000);
    }

    function draw() {
      // ç»˜åˆ¶èƒŒæ™¯
      background(0);
      
      // ç»˜åˆ¶æ‘„åƒå¤´è§†é¢‘ï¼ˆåŠé€æ˜ï¼‰
      tint(255, 77); // 30% é€æ˜åº¦
      image(video, 0, 0, width, height);
      noTint();
      
      // æ›´æ–°å¹¶ç»˜åˆ¶ç²’å­ç³»ç»Ÿ
      if (useManualControl) {
        fingerCount = manualFingerCount;
      }
      particleSystem.update(fingerCount);
      particleSystem.draw();
      
      // æ˜¾ç¤ºå½“å‰æ‰‹åŠ¿
      let gestureText;
      switch(fingerCount) {
        case 0: gestureText = 'æ¡æ‹³ - å°çƒ'; break;
        case 1: gestureText = '1æ ¹æ‰‹æŒ‡ - æ•°å­—1'; break;
        case 2: gestureText = '2æ ¹æ‰‹æŒ‡ - æ•°å­—2'; break;
        case 3: gestureText = '3æ ¹æ‰‹æŒ‡ - æ•°å­—3'; break;
        case 4: gestureText = '4æ ¹æ‰‹æŒ‡ - æ•°å­—4'; break;
        case 5: gestureText = '5æ ¹æ‰‹æŒ‡ - æ•£å¼€'; break;
        default: gestureText = `æ£€æµ‹åˆ°${fingerCount}æ ¹æ‰‹æŒ‡`;
      }
      if (useManualControl) {
        gestureText += ' (æ‰‹åŠ¨æ§åˆ¶)';
      }
      
      // åœ¨æŒ‡å®šä½ç½®æ˜¾ç¤ºæ‰‹åŠ¿æ–‡æœ¬
      fill(255);
      textSize(18);
      textAlign(LEFT, TOP);
      text(gestureText, 10, 10);
    }

    // å¤„ç†æ‰‹åŠ¿æ£€æµ‹ç»“æœ
    function gotHands(results) {
      predictions = results;
      console.log('results', results);
      
      // å¦‚æœä½¿ç”¨è‡ªåŠ¨æ£€æµ‹ï¼Œåˆ™æ›´æ–°æ‰‹æŒ‡è®¡æ•°
      if (!useManualControl && predictions.length > 0) {
        fingerCount = countFingers(predictions[0]);
      }
      
      // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
      if (debugEnabled && predictions.length > 0) {
        showDebugInfo(predictions[0]);
      }
    }

    // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
    function showDebugInfo(prediction) {
      const debugDiv = document.getElementById('debug');
      if (!debugDiv) return;
      
      // æ ¹æ®æ–°çš„æ•°æ®ç»“æ„æ›´æ–°è°ƒè¯•ä¿¡æ¯
      const keypoints = prediction?.keypoints;
      const debugInfo = `æ‰‹çš„æ•°é‡: ${predictions?.length}
å…³é”®ç‚¹æ•°é‡: ${keypoints?.length}
æ‰‹åŠ¿ç½®ä¿¡åº¦: ${(prediction?.confidence * 100).toFixed(2)}%
æ‰‹è…•ä½ç½®: ${keypoints?.[0] ? `${Math.round(keypoints[0].x)}, ${Math.round(keypoints[0].y)}` : 'N/A'}
æ‹‡æŒ‡å°–ä½ç½®: ${findKeypointByName(keypoints, 'thumb_tip') ? 
  `${Math.round(findKeypointByName(keypoints, 'thumb_tip').x)}, ${Math.round(findKeypointByName(keypoints, 'thumb_tip').y)}` : 'N/A'}
é£ŸæŒ‡å°–ä½ç½®: ${findKeypointByName(keypoints, 'index_finger_tip') ? 
  `${Math.round(findKeypointByName(keypoints, 'index_finger_tip').x)}, ${Math.round(findKeypointByName(keypoints, 'index_finger_tip').y)}` : 'N/A'}
`;
      
      debugDiv.textContent = debugInfo;
    }

    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    function showError(message) {
      const errorDiv = document.createElement('div');
      errorDiv.id = 'error';
      errorDiv.innerHTML = `<p>${message}</p>`;
      document.body.appendChild(errorDiv);
      
      // 3ç§’åè‡ªåŠ¨éšè—é”™è¯¯
      setTimeout(() => {
        if (errorDiv.parentNode) {
          errorDiv.parentNode.removeChild(errorDiv);
        }
      }, 3000);
    }

    // æ ¹æ®åç§°æŸ¥æ‰¾å…³é”®ç‚¹
    function findKeypointByName(keypoints, name) {
      if (!keypoints) return null;
      
      for (const keypoint of keypoints) {
        if (keypoint.name === name) {
          return keypoint;
        }
      }
      return null;
    }

    function countFingers(prediction) {
      if (!prediction) return 0;
      const kp = prediction;

      const dist = (a, b) => {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.sqrt(dx * dx + dy * dy);
      };

      const angle = (a, b, c) => {
        // è®¡ç®— âˆ abc
        const ab = { x: a.x - b.x, y: a.y - b.y };
        const cb = { x: c.x - b.x, y: c.y - b.y };

        const dot = ab.x * cb.x + ab.y * cb.y;
        const mag1 = Math.sqrt(ab.x ** 2 + ab.y ** 2);
        const mag2 = Math.sqrt(cb.x ** 2 + cb.y ** 2);

        const cos = dot / (mag1 * mag2);
        return Math.acos(Math.min(Math.max(cos, -1), 1)) * 180 / Math.PI;
      };

      let count = 0;
      const wrist = kp.wrist;

      // ğŸ‘‰ å››æ ¹é•¿æ‰‹æŒ‡
      const fingers = [
        ["index_finger_tip", "index_finger_mcp"],
        ["middle_finger_tip", "middle_finger_mcp"],
        ["ring_finger_tip", "ring_finger_mcp"],
        ["pinky_finger_tip", "pinky_finger_mcp"]
      ];

      fingers.forEach(([tipName, mcpName]) => {
        const tip = kp[tipName];
        const mcp = kp[mcpName];
        if (!tip || !mcp) return;

        const dTip = dist(tip, wrist);
        const dMcp = dist(mcp, wrist);

        if (dTip > dMcp * 1.15) {
          count++;
        }
      });

      // ğŸ‘‰ å¤§æ‹‡æŒ‡ï¼ˆè§’åº¦ + è·ç¦»ï¼‰
      const thumbTip = kp.thumb_tip;
      const thumbMcp = kp.thumb_mcp;
      const thumbCmc = kp.thumb_cmc;
      const indexMcp = kp.index_finger_mcp;

      if (thumbTip && thumbMcp && thumbCmc && indexMcp) {
        const thumbAngle = angle(thumbCmc, thumbMcp, thumbTip); // æ¥è¿‘180ä¸ºä¼¸ç›´
        const dThumb = dist(thumbTip, wrist);
        const dIndex = dist(indexMcp, wrist);

        const isThumbOpen =
          thumbAngle > 160 &&      // è§’åº¦æ¡ä»¶
          dThumb > dIndex * 0.9;   // è·ç¦»æ¡ä»¶

        if (isThumbOpen) count++;
      }

      return count;
    }

    // æ‰‹åŠ¨è®¾ç½®æ‰‹æŒ‡æ•°é‡
    function setFingerCount(count) {
      manualFingerCount = count;
      useManualControl = true;
      
      // éšè—æ‘„åƒå¤´ç”»é¢
      const videoEl = document.getElementById('video');
      videoEl.style.display = 'none';
      
      // æ›´æ–°æŒ‰é’®æ ·å¼
      document.getElementById('auto-detect-btn').textContent = 'å¼€å¯è‡ªåŠ¨æ£€æµ‹';
      document.getElementById('auto-detect-btn').style.backgroundColor = '#2196F3';
    }
    
    // å¯ç”¨è‡ªåŠ¨æ£€æµ‹
    function enableAutoDetection() {
      useManualControl = false;
      
      // æ˜¾ç¤ºæ‘„åƒå¤´ç”»é¢
      const videoEl = document.getElementById('video');
      videoEl.style.display = 'block';
      
      // æ›´æ–°æŒ‰é’®æ ·å¼
      document.getElementById('auto-detect-btn').textContent = 'å…³é—­è‡ªåŠ¨æ£€æµ‹';
      document.getElementById('auto-detect-btn').style.backgroundColor = '#f44336';
    }

    // ç²’å­ç³»ç»Ÿç±»
    class ParticleSystem {
      constructor() {
        this.particles = [];
        this.targetPositions = {};
        this.currentPositions = [];
        this.velocities = []; // æ–°å¢ï¼šç²’å­é€Ÿåº¦
        this.easing = 0.1; // è°ƒæ•´ç¼“åŠ¨å€¼
        this.particleCount = 1000;
        this.oscillationTime = 0; // æŒ¯è¡æ—¶é—´
        
        // åˆ›å»ºæ•°å­—ç”»å¸ƒç”¨äºé¢„æ¸²æŸ“
        this.digitCanvas = createGraphics(200, 200);
        this.digitCanvas.textAlign(CENTER, CENTER);
        this.digitCanvas.textSize(160);
        this.digitCanvas.fill(255);
        this.digitCanvas.noStroke();
        
        // é¢„å…ˆè®¡ç®—æ‰€æœ‰æ•°å­—å½¢çŠ¶
        this.precomputeShapes();
        
        // åˆå§‹åŒ–ç²’å­ï¼ˆæ–°å¢é€Ÿåº¦æ•°ç»„ï¼‰
        for (let i = 0; i < this.particleCount; i++) {
          this.particles.push({
            x: random(-width/2, width/2),
            y: random(-height/2, height/2),
            z: random(-200, 200),
            color: color(random(255), random(255), random(255)),
            // æ¯ä¸ªç²’å­æœ‰è‡ªå·±çš„æŒ¯è¡å‚æ•°
            oscillationOffset: random(TWO_PI),
            oscillationSpeed: random(0.08, 0.15), // æé«˜é€Ÿåº¦èŒƒå›´
            oscillationAmplitude: random(5, 15)   // æé«˜æŒ¯å¹…èŒƒå›´
          });
          
          this.currentPositions.push({
            x: this.particles[i].x,
            y: this.particles[i].y,
            z: this.particles[i].z
          });
          
          // åˆå§‹åŒ–é€Ÿåº¦
          this.velocities.push({
            x: 0,
            y: 0,
            z: 0
          });
        }
      }
      
      // é¢„æ¸²æŸ“æ•°å­—å¹¶æå–åƒç´ ä½ç½®
      renderDigitToCanvas(digit) {
        this.digitCanvas.clear();
        this.digitCanvas.text(digit.toString(), 100, 100);
        return this.digitCanvas.get();
      }
      
      extractPositionsFromImage(img, totalPoints) {
        const positions = [];
        
        // ç¡®ä¿åƒç´ æ•°æ®å·²åŠ è½½
        img.loadPixels();
        const pixels = img.pixels; // ä½¿ç”¨pixelså±æ€§è€ŒéloadPixels()
        const pixelDensity = img.pixelDensity();
        const d = pixelDensity;
        const w = img.width * d;
        const h = img.height * d;
        
        // æ”¶é›†æ‰€æœ‰ç™½è‰²åƒç´ çš„ä½ç½®
        const digitPoints = [];
        for (let y = 0; y < h; y += 3) { // é—´éš”é‡‡æ ·ï¼Œæé«˜æ€§èƒ½
          for (let x = 0; x < w; x += 3) {
            const idx = (x + y * w) * 4;
            if (idx + 3 < pixels.length) { // ç¡®ä¿ç´¢å¼•æœ‰æ•ˆ
              const r = pixels[idx];
              const g = pixels[idx + 1];
              const b = pixels[idx + 2];
              
              // å¦‚æœæ˜¯ç™½è‰²åƒç´ ï¼ˆæ•°å­—éƒ¨åˆ†ï¼‰
              if (r > 200 && g > 200 && b > 200) {
                // å°†ç”»å¸ƒåæ ‡è½¬æ¢ä¸ºå®é™…åæ ‡
                const mappedX = map(x, 0, w, -120, 120); // ç¨å¾®è¶…å‡ºè¾¹ç•Œ
                const mappedY = map(y, 0, h, -120, 120);
                digitPoints.push({ x: mappedX, y: mappedY, z: random(-20, 20) });
              }
            }
          }
        }
        
        // å¦‚æœæ”¶é›†åˆ°çš„ç‚¹ä¸å¤Ÿï¼Œéšæœºé‡å¤å·²æœ‰çš„ç‚¹
        while (positions.length < totalPoints) {
          if (digitPoints.length > 0) {
            const pt = random(digitPoints);
            // æ·»åŠ å°‘é‡éšæœºåç§»ä»¥å¢åŠ è‡ªç„¶æ„Ÿ
            positions.push({
              x: pt.x + random(-3, 3),
              y: pt.y + random(-3, 3),
              z: pt.z + random(-5, 5)
            });
          } else {
            // å¦‚æœæ²¡æ‰¾åˆ°ä»»ä½•ç‚¹ï¼Œåˆ›å»ºé»˜è®¤ä½ç½®
            positions.push({
              x: random(-100, 100),
              y: random(-100, 100),
              z: random(-20, 20)
            });
          }
        }
        
        return positions;
      }
      
      precomputeShapes() {
        // æ¸…ç©ºç°æœ‰å½¢çŠ¶
        this.targetPositions = {};
        
        // é¢„å…ˆè®¡ç®—æ¡æ‹³å½¢çŠ¶
        this.targetPositions[0] = [];
        for (let i = 0; i < this.particleCount; i++) {
          const radius = random(0, 50); // åŠå¾„50ï¼Œç›´å¾„100
          const theta = random(TWO_PI);
          const phi = random(PI);
          
          this.targetPositions[0].push({
            x: radius * sin(phi) * cos(theta),
            y: radius * sin(phi) * sin(theta),
            z: radius * cos(phi)
          });
        }
        
        // é¢„å…ˆè®¡ç®—æ•°å­—1å½¢çŠ¶
        const digit1Img = this.renderDigitToCanvas(1);
        this.targetPositions[1] = this.extractPositionsFromImage(digit1Img, this.particleCount);
        
        // é¢„å…ˆè®¡ç®—æ•°å­—2å½¢çŠ¶
        const digit2Img = this.renderDigitToCanvas(2);
        this.targetPositions[2] = this.extractPositionsFromImage(digit2Img, this.particleCount);
        
        // é¢„å…ˆè®¡ç®—æ•°å­—3å½¢çŠ¶
        const digit3Img = this.renderDigitToCanvas(3);
        this.targetPositions[3] = this.extractPositionsFromImage(digit3Img, this.particleCount);
        
        // é¢„å…ˆè®¡ç®—æ•°å­—4å½¢çŠ¶
        const digit4Img = this.renderDigitToCanvas(4);
        this.targetPositions[4] = this.extractPositionsFromImage(digit4Img, this.particleCount);
        
        // é¢„å…ˆè®¡ç®—æ•£å¼€å½¢çŠ¶
        this.targetPositions[5] = [];
        for (let i = 0; i < this.particleCount; i++) {
          this.targetPositions[5].push({
            x: random(-width/2, width/2),
            y: random(-height/2, height/2),
            z: random(-100, 100)
          });
        }
      }
      
      update(fingerCount) {
        // æ›´æ–°æŒ¯è¡æ—¶é—´
        this.oscillationTime += 0.02;
        
        // ä½¿ç”¨é¢„è®¡ç®—çš„ç›®æ ‡ä½ç½®
        const targetPos = this.targetPositions[fingerCount] || this.targetPositions[5];
        
        // æ ¹æ®æ‰‹æŒ‡æ•°é‡è°ƒæ•´æŒ¯è¡å¼ºåº¦
        let oscillationMultiplier = 1.0;
        if (fingerCount === 5) { // æ•£å¼€çŠ¶æ€æ—¶æŒ¯è¡æ›´æ˜æ˜¾
          oscillationMultiplier = 2.5; // æé«˜æŒ¯è¡æ•ˆæœ
        } else if (fingerCount === 0) { // æ¡æ‹³çŠ¶æ€æ—¶æŒ¯è¡è¾ƒå°
          oscillationMultiplier = 0.5;
        } else {
          oscillationMultiplier = 1.5; // å…¶ä»–æ•°å­—å½¢çŠ¶æŒ¯è¡é€‚ä¸­
        }
        
        const springConstant = 0.05; // å¼¹ç°§å¸¸æ•°
        const damping = 0.85; // é˜»å°¼ç³»æ•°
        
        // æ›´æ–°æ¯ä¸ªç²’å­çš„ä½ç½®
        for (let i = 0; i < this.particleCount; i++) {
          if (targetPos[i]) {
            // è®¡ç®—å¸¦æŒ¯è¡çš„ç›®æ ‡ä½ç½®
            const oscillationX = sin(this.oscillationTime * this.particles[i].oscillationSpeed + this.particles[i].oscillationOffset) * 
                                this.particles[i].oscillationAmplitude * oscillationMultiplier;
            const oscillationY = cos(this.oscillationTime * this.particles[i].oscillationSpeed * 1.2 + this.particles[i].oscillationOffset) * 
                                this.particles[i].oscillationAmplitude * oscillationMultiplier;
            const oscillationZ = sin(this.oscillationTime * this.particles[i].oscillationSpeed * 0.8 + this.particles[i].oscillationOffset) * 
                                this.particles[i].oscillationAmplitude * 0.5 * oscillationMultiplier;
            
            const targetX = targetPos[i].x + oscillationX;
            const targetY = targetPos[i].y + oscillationY;
            const targetZ = targetPos[i].z + oscillationZ;
            
            // è®¡ç®—å¼¹ç°§åŠ›ï¼ˆå‘ç›®æ ‡ä½ç½®æ‹‰å›ï¼‰
            const forceX = (targetX - this.currentPositions[i].x) * springConstant;
            const forceY = (targetY - this.currentPositions[i].y) * springConstant;
            const forceZ = (targetZ - this.currentPositions[i].z) * springConstant;
            
            // æ›´æ–°é€Ÿåº¦ï¼ˆåº”ç”¨å¼¹ç°§åŠ›å’Œé˜»å°¼ï¼‰
            this.velocities[i].x = (this.velocities[i].x + forceX) * damping;
            this.velocities[i].y = (this.velocities[i].y + forceY) * damping;
            this.velocities[i].z = (this.velocities[i].z + forceZ) * damping;
            
            // æ›´æ–°ä½ç½®
            this.currentPositions[i].x += this.velocities[i].x;
            this.currentPositions[i].y += this.velocities[i].y;
            this.currentPositions[i].z += this.velocities[i].z;
          }
        }
      }
      
      draw() {
        push();
        translate(width / 2, height / 2); // ç§»åˆ°ä¸­å¿ƒ
        
        for (let i = 0; i < this.particleCount; i++) {
          const pos = this.currentPositions[i];
          
          // ç®€å•çš„æ·±åº¦æ•ˆæœ
          const size = map(pos.z, -200, 200, 2, 8);
          const alpha = map(pos.z, -200, 200, 100, 255);
          
          fill(red(this.particles[i].color), green(this.particles[i].color), blue(this.particles[i].color), alpha);
          noStroke();
          ellipse(pos.x, pos.y, size, size);
        }
        
        pop();
      }
    }
  </script>
</body>
</html>